---
title: フロントエンド側の人間が 1からPythonを学んでみて① ～環境構築・基礎編～
tags: Python 業務効率化 初心者向け
author: benjuwan
slide: false
---
これは、筆者の「2025振り返り用ひとりアドカレ」記事の一つです。

## はじめに
これは誰しもそうでしょうが、日々の中で**差し込みの仕事**や**緊急対応を要するタスク**などが発生してスケジュール通りに進む状況は稀です。

筆者は普段 React, Next.js といったフロントエンドを主軸にしていますが、日々の業務においてずっと**イレギュラー対応を加味したバッファ駆動なスケジュール進行がしたい**と思っていました。
**余剰時間・余裕（バッファ）を作ることを目的にした働き方**をすれば少しは改善されるかもと期待したのです。

そこで、2025年は重い腰を上げて**業務効率化を絶対目標**にPythonを学ぶことにしました。

本記事は「フロントエンド側の人間が 1からPythonを学んでみて」というテーマのもと、以下の内容についてシリーズものとして書いていきたいと思います。

### 取り上げていく内容
- 筆者なりの学習ロードマップ
- 筆者がPython学習を通じて得た知識・情報
    - 仮想環境・パッケージインストール
    - データ構造（リスト・タプル・集合・辞書）
    - オブジェクト（class）
    - ループ処理・条件分岐
    - 内包表記 / ラムダ関数など Python 独自の機能
    - 関数定義・引数指定
    - 例外処理
    - 便利なメソッド・関数の紹介
    - 便利なライブラリの紹介
- フロントエンド系の言語やライブラリ・フレームワークとの違いや共通性

### 対象読者
- 業務効率化を願うビジネスパーソン
- バックエンド側に興味があるフロントエンド側の方々
- バックエンド側とフロントエンド側の言語における違いや共通性が知りたい方々
- Pythonを学び始めた方々
- Pythonを学ぼうとしているフロントエンドエンジニアの方々

::: note info
**わざわざ学ばなくても、AI（LLM）に任せれば良くね？**

筆者がPython学習のモチベーションとしたのは「**業務効率化を絶対目標**」とすることです。

正直これはAIで簡単に行える世界になりつつありますが、筆者はAIの成果物を正しく活用するには**チェックできるだけの基礎力が大事**だと思っています。

そのため遠回りに見えつつもPythonを体系的にじっくり学んでいくルートを選びました。
:::

まずは筆者なりの学習ロードマップについて書いていきますが飛ばしたい方は「[こちらへ](#pythonに触れる)」どうぞ。

## 筆者なりの学習ロードマップ
筆者はHTML, CSS, JavaScript / TypeScriptをはじめ、React, Next.js などフロントエンド側の知識や情報をある程度備えた状態でPython学習を始めました。

ですから、いまから説明する内容は全くの未経験という方には参考にならないかもしれませんが、考え方やところどころは参考になるのではと思っています。

### まずは公式情報

https://docs.python.org/ja/3/tutorial/

何はともあれ何でも一番初めは公式情報です。

しかし、惜しむらくは公式情報が中々分かりづらい場合も往々にしてあることです。

そんな時は書籍か動画学習に頼りましょう。

### 書籍 or 動画学習どっちを選ぶ？
これは個人の合う合わないで選ぶのが良いと思います。

筆者は「すぐにパッと開いて確認したいタイプ」で、知りたい内容を探す時に「大体このあたりのページにあったはず」といったような使い方をするので書籍派です。

大事なのは書籍であれ、動画学習であれ、**体系的に学べるかどうか**だと思っています。
インターネットには数多の情報がありますが「点ばかり集まっても線になって繋がらない」と理解には及びません。

学び始めの頃は「何が分からないのか分からない」という状況だと思うので、体系的に学んでいくのはとても大事だと思います。

---

ちなみに、筆者が学習に用いた書籍は以下です。

https://www.sbcr.jp/product/4815607647

発刊から数年経っていてページ数も多いのですが、筆者のじっくり学ぶという学習スタンスに合っていると感じたので購入しました。

結論から言うと、発刊から時が経っていることもあって現在のPython開発とは少し乖離があったり、自分で調べたりしなければならない部分もいくつかありました。
とはいえ、全くの未経験者を対象に書かれているので、すごく丁寧で分かりやすかったです。
未経験者にもおススメしたい書籍です。

## Pythonに触れる
### Pythonをダウンロード

node.js をはじめ、React, Next.js と同様にPythonもインストールして初めて利用できる（※）ようになります。

https://www.python.org/downloads/

::: note warn
※筆者は windows なのでインストールする必要がありましたが、Mac / Linux だと最初から入っています
:::

### 開発環境を整える（環境構築）
VSCodeを使っている前提で、必須及び便利な VSCode 拡張機能を紹介します。

![スクリーンショット 2025-12-11 110614.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3368730/f89c0651-0689-49c7-999f-ff29f1750fe4.png)

※`Path Autocomplete`はPythonに直接的な関係はありません

#### `Python`（必須）
- `Python`をインストールしたら付随される拡張機能たち
`Pylance`, `Python Debugger`

#### `Ruff`
`Linter`+`Formatter`機能を提供してくれます。一つの拡張機能でこれを実現してくれるのは強力ですね！

設定方法含めて詳細は以下の記事が分かりやすいです。

https://qiita.com/musutafakemaru/items/332bd0193828aa66461d#ruff%E3%82%AA%E3%82%B9%E3%82%B9%E3%83%A1%E3%81%AE%E5%88%9D%E6%9C%9F%E8%A8%AD%E5%AE%9A

::: note info
- `Linter`（リンター）
プロジェクトにおけるコード規約や命名規則、構文チェックなど安全・堅実な開発実現をサポートしてくれるツール

- `Formatter`（※フロントエンドでいう`Prettier`）
インデント位置調整や末尾のセミコロン付与などコード整形を行い、可読性を高めてくれるツール
:::

#### `Mypy Type Checker`（`mypy`）
動的型付け言語の`Python`に型を付与してくれます。

::: note info
「動的型付け」とはランタイム（実行）時に初めて型が付くことです。
JavaやTypeScriptは「静的型付け」で**事前に型を付けておいて型エラーを検知できます**が、動的型付けの場合は**ランタイム（実行）時にエラー**となってしまいます。

事前に型エラーで問題を把握できると本番環境で予期せぬエラーに遭遇する要因を減らせるので「静的型付け」の方が安全な開発を行えます。
:::

#### 筆者は使用していないが主流になりつつあるツール
##### `uv`
これはPythonの仮想環境構築からパッケージマネージャーの役割まで担う上に高速だというツールです。

筆者は学び始めということもあって**Python標準**を意識したので採用することはありませんでした。
[仮想環境](#仮想環境)については後述しますが、調べると筆者のような小～中規模程度だとPython標準の`venv`（と`requirements.txt`）で十分ということだったので、そういった点でも採用を見送りました。

### Python基礎編
Pythonには独特なルールがいくつかあります。
最たる例が「オフサイドルール」です。
（※Pythonに限らず Haskell といった言語でも採用されている）

オフサイドルールとは、**インデントやスペースが単なるコード整形ではなく「コードの意図や構造を表現」する**仕組みを指します。

つまり以下コードの初めのコード例のような記述はPythonではエラーとなります。

```py
# エラーになるコード（※内部処理がインデントされていない）
for elm in iterable:
print(f"これは、{len(iterable)}ある内の一つ「{elm}」です。")

# 正しいコード
for elm in iterable:
    print(f"これは、{len(iterable)}ある内の一つ「{elm}」です。")
```

::: note info
コード例にある`f"文章"`は **`f`文字列** といいます。

これは JavaScript でいう`テンプレートリテラル（バックティック）`の記法と似たものです。

`{}`の中に変数や式、処理をそのまま記述して（その結果を反映した）文字列を表現できます。
:::

あと、Pythonでは**文の末尾にセミコロンは原則不要**です。
```
// TypeScriptの場合
const helloWorld: string = "hello world";

// Pythonの場合
hello_world: str = "hello world"
```

::: note info
このようにPythonでは記述に関してある種の制約があります。
しかし、そのお陰で自分たちのコーディングガイドラインを別途作成する必要がないので楽は楽ですよね。

インデントの字下げ数（例：2文字でも、4文字でも）や変数の命名方法などは開発者が自由にしてもPythonの構文に準拠してさえいれば機能します。

とはいえ、自由気ままにして良いわけではなく、Pythonでは「[PEP8](https://pep8-ja.readthedocs.io/ja/latest/)」というコーディングガイドラインが用意されています。
例えば「字下げ数は4文字にする」とか「関数宣言箇所の改行は2行入る」とか色々です。

※PEP8： Python コミュニティが定めたコードスタイルの推奨ガイドライン
:::

他にも、Pythonは Java など一部の言語にある**ガベージコレクション**を備えています。

::: note info
- ガベージコレクション
使用していない（変数や）データの参照を削除してメモリを解放することでメモリリークを防止する機能
:::

#### フロントエンド側から見たPythonの独自性
オフサイドルールの他にもフロントエンド側では見たことのない世界がPythonには広がっていました。

##### インタプリタ
コンパイラ方式（プログラムのソースコードを一度にすべて機械語に変換して実行する）とは異なり、Pythonは実行時に逐次処理していくインタプリタ型の言語です。

::: note info
- Python対話モード（REPL）の終了方法
  - Windows: `Ctrl + Z` → `Enter`
  - Mac/Linux: `Ctrl + D`
  - 共通: `exit()` または `quit()` を入力
  
  ※ `Ctrl + C` は実行中の処理を中断する際に使用
:::

##### コマンドラインからインタプリタを起動して実行する
フロントエンドの`index.html`などはブラウザのアドレスバーにペーストしたり、JavaScriptはブラウザの開発者ツールを開いて`Console`パネルで実行できたりなど**ブラウザ側で簡単に確認・実行**できます。

他方、Python はスクリプト言語であり、`python ファイル名.py`のようにコマンドラインからインタプリタを起動して実行するのが基本的な使い方です。

::: note info
ただし、Pythonの Webフレームワーク（Flask / Django / FastAPI など）を使うと、Python で作った処理をHTTPサーバーとして起動し、ブラウザから確認することは可能です。
:::

###### Pythonファイルの実行
以下のPythonプロジェクトがあるとします。

```
my-python
    |-utils
        |-sample.py
    |-libs
```

上記構成にある`sample.py`を実行したいと思います。
Pythonプロジェクト（my-python）をターミナル（コマンドプロンプト）で実行するか、VSCodeで開きます。

```bash
# 1. ターミナル（コマンドプロンプト）で実行する場合
# デスクトップにPythonプロジェクト（my-python）があると想定
cd desktop
cd my-python

# 2. VSCode でPythonプロジェクト（my-python）を開いた場合
# および先ほど（1.）の手順の続き
# 実行したいファイルのあるディレクトリへ移動
cd utils

# Pythonファイルを実行
python sample.py
```

または以下のように記述
```bash
python utils/sample.py
```

上記のようにPythonでは、コマンドラインで明示的に指定することで処理を実行（挙動確認）できます。

##### `null`は`None`
JavaScriptでいう`null`は、Pythonでは`None`になります。

また、JavaScript には「存在しない変数を参照すると`undefined`になる」という挙動がありますが、Python では存在しない名前（変数）を参照すると`NameError`（未定義名エラー）が発生します。

つまり「`undefined`に相当する値は Python にはない」と思っておいて問題ありません。

###### Pythonでの型定義について
```py
# TypeScript `const theStr: string`
theStr: str = 'hoge'

# TypeScript `const theNum: number`
theNum: int = 0

# TypeScript `const theStrOrNum: string | number` 
theStrOrNum: str | int = 100

# TypeScript `const theBool: boolean`
theBool: bool = True  # または False

# TypeScript `const theAry_str: string[]`
theAry_str: list[str] = ['hoge', 'foo', 'bar']

# TypeScript `const theAry_int: number[]`
theAry_int: list[int] = [10, 100]

# TypeScript `const theAry_StrOrInt: (string | number)[]`
theAry_StrOrInt: list[str | int] = [10, "hoge", 100, "foo", True] 
# True は 1 として扱われる（bool は int としても扱えるため）が、
# 明示的に 1 に置き換えた方がわかりやすい
```

::: note warn

Python には TypeScript にない`float`という型があります。
`float`はPHPのそれと同じく`浮動小数点数`を指します。
例えば、`3.14`などは`float`型（浮動小数点数）です。

:::

##### 変数について
Pythonでは、JavaScriptでいう変数宣言（`let`や`const`）を用いずに変数を作成するため`var`のように再宣言も再代入（再定義）も可能な仕様になっています。
例えば、定数を作成する方法はなく、普通の変数を使用するため、変更（再代入）しようと思えばできてしまうのです。

命名規則については以下のようになっています。

- 変数や関数、モジュール名・パッケージ名
**単語の区切りは基本的に`スネークケース`（`_`：アンダースコア）** 
```py
hoge_foo_bar
```

- クラスの命名
**`パスカルケース`（`アッパーキャメルケース`）**
```py
HogeFooBar
```

- 定数
**`大文字+スネークケース`** 
```py
HOGE_FOO_BAR
```

::: note info
`Python`では、変数は明示的に管理・把握しやすくするためにあるもので、実際は**値ごとに付与される参照値（メモリアドレス）に紐づくオブジェクトで管理**される言語仕様になっています。

つまり、変数は値を格納する箱ではなく、オブジェクトに付けられた『名札』のようなものです。

※参照値（メモリアドレス ／ オブジェクトID）の確認は`id(変数)`で行える。
:::

<details><summary>変数が全てグローバルになるなんて管理が大変じゃない？</summary>

##### `global` / `nonlocal`を活用する
Pythonでは、**スコープ内に同名の変数がある場合はスコープ内のものが優先（適用）**されます。
しかし、`global`宣言子を用いることで**グローバル変数に代入**できるようになるのです。

```py
def good_morning():
    global txt
    txt = "good morning"
    print(f"good_morning: {txt}")


txt = "good afternoon"
good_morning()
print(txt)

# global 無効時の出力結果
# good_morning: good morning
# good afternoon  # 関数実行時前の代入が有効になっている

# global 有効時の出力結果
# good_morning: good morning
# good morning
```

**関数内の関数で同名の変数を扱う**かつ上記`global`のような振る舞いを行いたい場合は`nonlocal`を用います。

```py
def good_morning_afternoon():
    def good_afternoon():
        nonlocal good_afternoon_txt
        good_afternoon_txt = "good afternoon"
        print(f"good_afternoon: {good_afternoon_txt}")

    good_afternoon_txt = "hello world."
    good_afternoon()
    print(f"good_morning_afternoon: {good_afternoon_txt}")


good_morning_afternoon()

# nonlocal 無効時の出力結果
# good_afternoon: good afternoon
# good_morning_afternoon: hello world.  # 関数実行時前の代入が有効になっている

# nonlocal 有効時の出力結果
# good_afternoon: good afternoon
# good_morning_afternoon: good afternoon
```

</details>

#### 仮想環境
フロントエンド開発でもそうですが、**何でもかんでもnpmなどをグローバルインストールしていたらverの競合が起きたり、PCのパフォーマンスに影響が出たり**します。

これはPythonに限らずweb開発では、**特定のプロジェクトでは専用または特化した環境を用意する**のが一般的です。

##### 筆者の失敗
筆者は「Pythonでは**仮想環境を使わない場合、`pip install パッケージ / モジュール名`はグローバル環境にインストールするという仕様**」を知らなかったので、初めての開発では**使用していた`pipライブラリ`が全てグローバルインストールされて**いました。

フロントエンド開発における **`npm install`はプロジェクトスコープ** なので明示的なコマンドを使用しない限りグローバルインストールされる心配はありません。

しかし、Pythonでは前述通り仮想環境を用意していない場合、**`pip install パッケージ / モジュール名`はグローバル環境にインストールするという仕様**なので、全てがグローバルインストールされていました。

ちなみに、アンインストールはnpm同様以下のように行えます。
```py
pip uninstall パッケージ / モジュール名
```

仮想環境に関しては、`Python`標準のvenvというものがあります。
仮想環境構築は情報量が多くなるのでまた別記事にしたいと思います。

---

このように（Pythonだけではないものの）環境構築が面倒な場合もあります。
そこでPythonを手軽に実行できる環境がいくつか用意されています。

例えば、`Anaconda`や`Jupyter Notebook`, `Google Colab`などがあります。
※`Anaconda`は一定以上の規模の企業で利用する場合に、ライセンス料がかかってしまうので注意

## さいごに
本記事では初回として主にPythonの概要や基礎理解、環境構築などに触れてきました。

次の記事では、仮想環境・パッケージインストールについて書いていきたいと思います。

ここまで読んでいただき、ありがとうございました。

