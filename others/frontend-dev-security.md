# frontend-dev-security
[フロントエンド開発のためのセキュリティ入門 知らなかったでは済まされない脆弱性対策の必須知識](https://www.shoeisha.co.jp/book/detail/9784798169477)に関するまとめ（個人的備忘録）

## 前提として
- セキュリティの動向は時代背景や攻撃手法の変化から年々変わるものという意識を持つ

## 細目
### 機能要件・非機能要件
#### 機能要件
顧客からのヒアリングなどを通じて得る顧客要望（システムで必ず満たすべき）を指す
#### 非機能要件
セキュリティ対策をはじめ、サイトのサーバー負荷対策、レスポンス速度、SEO対策など開発するシステムを利用する上で主目的にならないような事項を指す

> [!NOTE]
> IPA（情報処理推進機構）が出している「[非機能要求グレード](https://www.ipa.go.jp/archive/digital/iot-en-ci/jyouryuu/hikinou/ent03-b.html)」というものがある
> > 「非機能要求グレード」は、「非機能要求」についてのユーザと開発者との認識の行き違いや、互いの意図とは異なる理解を防止することを目的とし、非機能要求項目を網羅的にリストアップして分類するとともに、それぞれの要求レベルを段階的に示したものです。重要な項目から順に要求レベルを設定しながら、両者で非機能要求の確認を行うことができるツール群です。
> ---
> #### 非機能要求の6つのカテゴリ
> 1. 可用性（Availability）
> 概要: システムがどれだけの時間、停止せずに稼働できるか。
> 例: 稼働時間の割合（稼働率99.99%など）、障害時の復旧時間、メンテナンス時間帯の明示。
> 2. 性能・拡張性（Performance and Scalability）
> 概要: システムの応答速度や処理能力、将来的な拡張のしやすさ。
> 例: 画面表示の応答時間、同時アクセス数、スループット、拡張に要する工数や影響範囲。
> 3. 運用・保守性（Operability and Maintainability）
> 概要: システムの運用のしやすさ、障害対応や変更対応のしやすさ。
> 例: 障害発生時のログ出力内容、設定変更の容易さ、運用手順書の有無。
> 4. 移行性（Portability）
> 概要: 他の環境やバージョンへシステムを移行する際の容易さ。
> 例: データ移行の手段、OS変更時の対応範囲、バージョンアップ時の互換性。
> 5. セキュリティ（Security）
> 概要: システムやデータを不正アクセスや破壊から守る能力。
> 例: 認証方式、アクセス権管理、通信の暗号化、ログの改ざん防止。
> 6. システム環境・エコロジー（System Environment and Ecology）
> 概要: システムが稼働するための環境条件や、環境負荷の配慮。
> 例: 対応ブラウザ・OS、電力消費、設置スペース、利用端末制限。

## TCP/IP
### TCP/IPの4つのレイヤーとその役割・代表的なプロトコル
### アプリケーション層：レイヤー4
- **主な役割**: アプリケーションに応じた通信をする
- **代表的なプロトコル**: HTTP, FTP, DNS, SMTP, POP3, IMAP

### トランスポート層：レイヤー3
- **主な役割**: インターネット層から受け取ったデータをどのアプリケーション層に渡すかを決めたり、データの誤りを検知したりする
- **代表的なプロトコル**: 
  - **TCP**: 送信したデータを確実に相手に届けたい場合
  - **UDP**: リアルタイム通信など速度を重視したい場合

### インターネット層：レイヤー2
- **主な役割**: どのコンピュータにデータを届ける（伝達経路の選択：ルーティングする）か決定する
- **代表的なプロトコル**: IP, ICMP, ARP, IGMP

### ネットワークインターフェース（データリンク）層：レイヤー1
- **主な役割**: 通信機器は文字や数字のデータをそのまま送ることができず、物理的に送信可能な電気信号に変換してデータをやりとりする。データリンク層は電気信号を相手に届けたり、電気信号の伝送制御や誤りの検知を行う
- **代表的なプロトコル**: 
  - **Ethernet**: 有線LAN
  - **IEEE 802.11**: 無線LAN
  - **Wi-Fi**: 無線LAN（※Wi-FiはIEEE 802.11規格の商標名なので実質的には同じもの）
  - **PPP**: Point-to-Point Protocol

### 実際の通信フロー例
- データ送信時：アプリケーション層 → トランスポート層 → インターネット層 → ネットワークインターフェース層
- データ受信時：ネットワークインターフェース層 → インターネット層 → トランスポート層 → アプリケーション層
この階層構造により、各レイヤーは独立して機能し、保守性と拡張性を高めています。

## HTTPメッセージ
### HTTPメッセージの形式
リクエストとレスポンスの2種類あるが形式は以下同じ

```
開始行
----------
メッセージヘッダ
----------
空白行
----------
メッセージボディ
```

#### HTTPリクエスト
HTTPによるブラウザとサーバの通信は、ブラウザからサーバへ要求を送ることからはじまる。<br>
この要求を送ることをリクエスト（処理要求）という。

```bash
# リクエストライン
POST / HTTP/1.1
# ヘッダ：2行目から空白行まで
Host: localhost:8080
Connection: keep-alive
...
..
.
Cache-Control: max-age=0
# 空白行（ここまでヘッダ）
# ボディ：以降の行
id=1&user=hoge
```

- リクエストライン<br>
`GET`や`POST`といったHTTPメソッドをはじめ、リソースのパス名、HTTPバージョンが含まれている
- ヘッダ<br>
ブラウザの情報や接続に関する情報などデータのやりとりに必要な付加情報が含まれている
- ボディ<br>
リクエスト本文。取得したい情報のキーワードや登録したい情報が記載されている（※リクエスト内容によってはボディが空の場合もある）

#### 代表的なリクエストヘッダ
開発者ツールの`Network`パネルから確認可能

##### Host
- **概要**: リクエスト先のホスト名とポート番号を指定
- **例**: `Host: www.example.com`

##### User-Agent
- **概要**: クライアントのブラウザやアプリケーションの情報を送信
- **例**: `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36`

##### Accept
- **概要**: クライアントが受け入れ可能なコンテンツタイプを指定
- **例**: `Accept: text/html,application/json`

##### Accept-Language
- **概要**: クライアントが希望する言語を指定
- **例**: `Accept-Language: ja,en-US;q=0.9`

##### Accept-Encoding
- **概要**: クライアントが対応している圧縮方式を指定
- **例**: `Accept-Encoding: gzip, deflate, br`

##### Authorization
- **概要**: 認証情報（トークンやパスワード）を送信
- **例**: `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`

##### Cookie
- **概要**: 以前にサーバーから送信されたクッキーを送信
- **例**: `Cookie: session_id=abc123; user_pref=dark_mode`

> [!IMPORTANT]
> - 補足<br>
> ページ遷移時やフォーム送信時といったリクエスト処理時に、**ブラウザは`Cookie`を自動的にサーバへ送信**する。
> この働きにより元来ステートレスなHTTPが状態（ログイン有無やカートの中身などの情報）維持できるようになる。

##### Referer
- **概要**: リクエストの元となったページのURLを指定
- **例**: `Referer: https://www.google.com/search?q=example`

##### If-Modified-Since
- **概要**: 指定日時以降に更新されたリソースのみを要求
- **例**: `If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT`

#### HTTPレスポンス
リクエスト（ブラウザからサーバへの処理要求）に応じて、サーバが送信する情報をレスポンスという。

```bash
# ステータスライン
HTTP/1.1 200 OK
# ヘッダ：2行目から空白行まで
content-encoding: gzip
content-type: text/html;
...
..
.
content-lenght: 648
# 空白行（ここまでヘッダ）
# ボディ：以降の行
<!doctype html>
<html>
...
..
.
```

- ステータスライン<br>
リクエストに応じたサーバの処理結果。200：正常終了, 400系：クライアントエラー, 500系：サーバエラー
- ヘッダ<br>
サーバに関する情報や送信したリソースの形式などの付加情報が含まれている
- ボディ<br>
レスポンス本文。リクエストされた情報やサーバの処理結果などが記載されている（※リクエスト内容によってはボディが空の場合もある）

#### 代表的なレスポンスヘッダ
開発者ツールの`Network`パネルから確認可能

##### Status
- **概要**: HTTPステータスコードとメッセージを示す
- **例**: `200 OK`, `404 Not Found`, `500 Internal Server Error`

##### Server
- **概要**: サーバーソフトウェアの情報を送信
- **例**: `Server: Apache/2.4.41 (Ubuntu)`

##### Set-Cookie
- **概要**: クライアントにクッキーを設定（保存）するよう指示
- **例**: `Set-Cookie: SESSION_ID=abc123; Path=/; HttpOnly`
    - **保存形式**：`SESSION_ID: abc123`（`キー: 値`）

> [!NOTE]
> ##### セッション
> 訪問先サイトのサーバ側で管理する「訪問ユーザーの状態情報」。<br>HTTPは原則ステートレス（※前回のやり取り内容を覚えていない）なので、セッションを用いてユーザーのログイン有無やカート情報、クッキーやキャッシュ情報などを管理する
> ###### クッキー
> セッションIDをはじめ、言語設定や表示設定など先のユーザー固有情報を管理・把握する一意の識別子。<br>訪問先サイトのサーバーが発行し、閲覧ブラウザに保存される。4kbほどのデータ容量しか無いので多くの情報は保存できない
> ###### キャッシュ
> 訪問先サイトのアセットデータ（画像やファイルなど）を一時的に保持してブラウザのレンダリング負荷を軽減する働きを持つ

##### Location
- **概要**: リダイレクト先のURLを指定（主に3xxステータスで使用）
- **例**: `Location: https://www.example.com/new-page`

##### Cache-Control
- **概要**: キャッシュの動作を制御
- **例**: `Cache-Control: no-cache, must-revalidate`

##### Expires
- **概要**: リソースの有効期限を指定
- **例**: `Expires: Wed, 21 Oct 2015 07:28:00 GMT`

##### Last-Modified
- **概要**: リソースが最後に更新された日時を示す
- **例**: `Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT`

##### ETag
- **概要**: リソースの固有識別子（バージョン管理用）
- **例**: `ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"`

##### WWW-Authenticate
- **概要**: 認証が必要な場合の認証方式を指定
- **例**: `WWW-Authenticate: Basic realm="Restricted Area"`

##### HTTPメソッド
- GET
    - 役割: サーバーからリソースを取得する
    - 特徴: 安全で冪等性がある（何度実行しても同じ結果）
    - 使用例: Webページの表示、データの取得

- POST
    - 役割: サーバーにデータを送信して新しいリソースを作成する
    - 特徴: 安全ではなく、冪等性もない
    - 使用例: フォームの送信、ユーザー登録、データの作成

- PUT
    - 役割: サーバー上のリソースを更新または新規作成する
    - 特徴: 冪等性がある（同じ操作を繰り返しても結果は同じ）
    - 使用例: ファイルのアップロード、データの完全更新

- DELETE
    - 役割: サーバー上のリソースを削除する
    - 特徴: 冪等性がある
    - 使用例: ファイルの削除、ユーザーアカウントの削除

- HEAD
    - 役割: GETと同じだが、レスポンスボディを返さずヘッダーのみを取得
    - 特徴: 安全で冪等性がある
    - 使用例: リソースの存在確認、メタデータの取得

- CONNECT
    - 役割: プロキシサーバーを通じてSSL/TLSトンネルを確立する
    - 特徴: 主にHTTPS通信でプロキシを経由する際に使用（※通信先の制限などをしないと攻撃者に悪用されるリスクがある）
    - 使用例: プロキシサーバー経由でのHTTPS接続、VPN接続

- OPTIONS
    - 役割: サーバーがサポートしているHTTPメソッドを確認する
    - 特徴: 安全で冪等性がある
    - 使用例: CORS（Cross-Origin Resource Sharing）での事前確認

- PATCH
    - 役割: リソースの部分的な更新を行う
    - 特徴: 冪等性は実装によって異なる
    - 使用例: ユーザー情報の一部更新、設定の変更

- TRACE（現在ではほとんど使用されていない）
    - 役割: クライアントのリクエストがサーバーに到達するまでの経路を確認
    - 特徴: 安全で冪等性がある
    - 使用例: デバッグ、ネットワーク診断（セキュリティ上の理由で無効化されることが多い）

#### 代表的なエンティティヘッダ
リクエストとレスポンスのどちらにも使えるHTTPヘッダのことをエンティティヘッダという。

##### Content-Type
- **概要**: 送信データ（リソース）のメディアタイプを指定
- **例**: `Content-Type: application/json; charset=utf-8`

##### Content-Length
- **概要**: 送信データ（リソース）のバイト数を指定
- **例**: `Content-Length: 1024`

##### Content-Encoding
- **概要**: データの圧縮方式を指定
- **例**: `Content-Encoding: gzip`

##### Content-Language
- **概要**: データの言語を指定
- **例**: `Content-Language: ja`

##### Content-Location
- **概要**: データの元となる場所のURLを指定
- **例**: `Content-Location: /documents/report.pdf`

##### Content-Disposition
- **概要**: データの処理方法を指定（インライン表示またはダウンロード）
- **例**: `Content-Disposition: attachment; filename="report.pdf"`

##### Content-Range
- **概要**: 部分的なデータ送信時の範囲を指定
- **例**: `Content-Range: bytes 200-1023/2048`

##### Allow
- **概要**: リソースで使用可能なHTTPメソッドを指定
- **例**: `Allow: GET, POST, PUT, DELETE`

## HTTPSの仕組み
HTTPSとは、暗号化されておらず、改ざんなどのリスクがあるHTTP（通信）の危険性を回避するための技術であり通信規格を指す。

### TLS（Transport Layer Security）
HTTPSは、TLSという通信プロトコルを用いてHTTPデータを暗号化して通信している
- HTTPデータをやり取りする前に、TLSハンドシェイクという一連の手順によって暗号通信を確立する<br>
TLSでの通信では、**通信データの暗号化**、**通信相手の検証**、**通信データの改ざんチェック**などを実現する

#### TLSによる 通信データの暗号化
プレーンテキストを暗号化して相手へ送り、受信側は復号してデータの中身を確認できる。暗号化と復号化に必要な鍵（秘密鍵）は、ブラウザとサーバーが情報のやり取りを行って安全に共有する。つまり、鍵を持つ者だけが復号できるので安全ということ。

- 秘密鍵<br>
TLSの通信ごとに作られる一時的なもので、通信が終わると廃棄される。これにより、データの盗聴や改ざんなどを防いでいる

#### TLSによる 通信相手の検証
電子証明書を用いて通信相手が本物かどうかを検証する。電子証明書は、認証局（CA）と呼ばれる社会的に信頼されている機関が発行していて、サーバーから送信された電子証明書が正しいかどうかをブラウザが検証する。<br>
あらかじめ、ブラウザやOSには電子証明書が組み込まれていて、それらと照合する仕組みなので、もしCAから発行されていない電子証明書が使用されている場合にブラウザは警告画面（例：この接続ではプライバシーが保護されません）を表示する。<br>
つまり、サーバー側は必ず信用できるCAから発行される電子証明書を用いなければならない。

#### TLSによる 通信データの改ざんチェック
改ざんがなかったことを証明するために**認証タグ**という検証用データをTLSは用いる。認証タグはデータの暗号化と同時に作成され、通信相手に送信される。<br>
受信側は復号と同時に認証タグを使って暗号文の改ざんチェックを実施し、もし形跡があった場合は通信は行われずにエラー処理される。ちなみに、改ざんチェックに関しては、TLSハンドシェイク中にも実施されている。

### HTTPS通信でないと処理できない内容（Secure Context）

- Service Workers<br>
オフラインでもwebアプリケーションを表示可能とする機能

- Payment Request API<br>
web上の決済を手軽に実現するための機能。ブラウザに記憶させた決済情報を使って決済が行える

---

上記のような機能はWebサービスや開発の拡充に有用だが、Payment Request API など悪用されるとリスクの高いものもある。そのため、これら機能に関しては「安全なコンテキスト（Secure Context）」上でのみ利用可能となっている。具体的には以下の条件を満たすと Secure Context とみなされる。

- https:// または wss:// といった暗号通信で配信されている
- http://localhost, http://127.0.0.1, file:// といったローカルホスト通信

※Secure Contextを要件としているブラウザの機能は先の2つ以外にもたくさんある

### Mixed Contentの危険性
Mixed Content とは（HTTPS化されたWebアプリケーション内で）https通信またはhttp通信で読み込んでいるファイルが一つのwebページ内で混在している際に発生する警告。<br>
Passive mixed content（画像や音声、動画ファイルなど）はそこまでリスクはないものの、Active mixed content（JavaScriptやCSSファイルなど）というプログラムに影響を与えるものが Mixed Content の場合はリスクが高まる。<br>
※Chrome, Firefox, Safari など主要ブラウザは別サイトから配信されている Active mixed content のサブリソースへのアクセスをブロックする。

## オリジンに関する事項
### 同一オリジンポリシー（Sama-Origin Policy）
ブラウザに組み込まれているアクセス制限の仕組み。異なるwebアプリケーションとの間に境界（オリジン）を設けるブラウザの機能によって、開発者は特別な対策をしなくともwebアプリケーションからのアクセスを制限できる。

- オリジン（Origin）<br>
異なるwebアプリケーション同士でアクセスを制限するための境界を指す。基本的にオリジンは`スキーム（プロトコル）`、`ホスト名（ドメイン名）`、`ポート番号`で構成される。

```
https://example.com:443/about

- https://
スキーム（プロトコル）

- example.com
ホスト名（ドメイン名）

- :443
ポート番号
    - ポート番号例：
        - 80, 8080 | http://
        - 443 | https://
        - 21 | FTP
        - 3000, 5173, 5174 ... | localhost

- about
パス
```

> [!IMPORTANT]
> スキーム、ホスト、ポート番号のいずれかが異なる場合は**クロスオリジン（Cross-Origin）**となる

ブラウザはデフォルトで同一オリジンポリシーを有効にしていて、以下のようなアクセスは制限される。

- JavaScript を使ったクロスオリジンへのリクエスト送信
- JavaScript を使った iframe内のクロスオリジンのページへのアクセス
- クロスオリジンの画像を読み込んだ <canvas> 要素のデータへのアクセス
- Web Storage や IndexDB に保存されたクロスオリジンのデータへのアクセス

※他にも制限される機能はいくつかある。

#### JavaScript を使ったクロスオリジンへのリクエスト送信
`fetch API`や`XMLHttpRequest`を使ったクロスオリジンへのリクエストは制限される。具体的にはCORS（クロスオリジン・リソース・シェアリング）に関するエラーが表示されて、回避するにはCORSに則ったアプローチを採る必要がある。

#### JavaScript を使った iframe内のクロスオリジンのページへのアクセス
Webアプリケーション内に iframeで埋め込んだクロスオリジンのページへのアクセスは制限される。<br>
ただし、`postMessage`関数を利用することでデータの送信元のオリジンをチェックできるためクロスオリジンでも安全にデータのやり取りが行える。

#### クロスオリジンの画像を読み込んだ <canvas> 要素のデータへのアクセス
クロスオリジンの画像を読み込んだ <canvas> 要素は汚染された状態とみなされてデータの取得に失敗する。この制限を回避するにはCORSが必要となる。

#### Web Storage や IndexDB に保存されたクロスオリジンのデータへのアクセス
Web Storage（localStorage, sessionStorage）や IndexDB といったブラウザの組み込みデータベース機能に保存されたデータも、同一オリジンポリシーによりアクセスを制限されている。sessionStorage は、オリジン間のみならず新しく開いたタブやウィンドウ間のアクセスも制限する。<br>
つまり、ユーザーが罠サイトにアクセスしてしまっても**ブラウザに保存されたデータは同一オリジンからしかアクセスできないので罠サイトへ情報漏洩することはない**。ただし、**以下の注意書きに留意**すること。

> [!NOTE]
> 1. XSSがあればアウト<br>
> 同一オリジン内でスクリプトを実行できる脆弱性（XSS）がある場合、罠サイト経由でそのオリジンにスクリプトを注入し、保存データを盗み出される。
> 2. クロスサイトスクリプトインクルージョン（XSSI）やJSONP的手法は関係なし<br>
> localStorageやIndexedDBは「DOM API」でしかアクセスできないため、<script src> などでは直接読み出せないものの、アプリがデータをサーバー経由で返す仕組みを持っていると、別経路から抜かれる可能性がある。
> 3. ブラウザバグや拡張機能による漏洩<br>
> ごくまれにブラウザ実装の不具合や悪意ある拡張機能で読み出される例もある（安全設計では防ぎにくい）。

#### 制限されないクロスオリジンアクセス事例（8例）
1. **`<script>` 要素によるクロスオリジン JavaScript 読み込み**  
   - 例:  
     ```html
     <script src="https://cross-origin.com/app.js"></script>
     ```  
   - JavaScriptファイルはCORS不要でロード可能（ただし実行されるのは読み込んだコード）。  

2. **`<img>` 要素によるクロスオリジン画像読み込み**  
   - 例:  
     ```html
     <img src="https://cross-origin.com/image.png">
     ```  
   - 表示は可能だが、`canvas` に描画してピクセル情報を読む場合は `crossorigin` 属性やCORS対応が必要。

3. **`<link rel="stylesheet">` によるクロスオリジンCSS読み込み**  
   - 例:  
     ```html
     <link rel="stylesheet" href="https://cross-origin.com/style.css">
     ```  
   - CSSはCORS不要で適用可能（ただし、`@import`内で画像やフォントを読み込むときに挙動が異なる場合あり）。

4. **`@font-face` によるクロスオリジンWebフォント読み込み**  
   - 例:  
     ```css
     @font-face {
       font-family: 'MyFont';
       src: url('https://cross-origin.com/font.woff2');
     }
     ```  
   - 多くのブラウザはフォントにCORS制約を課すが、古いブラウザや特定設定では制限されずに使えることがある。

5. **`<video>` / `<audio>` によるクロスオリジンメディア読み込み**  
   - 例:  
     ```html
     <video src="https://cross-origin.com/video.mp4" controls></video>
     ```  
   - 再生は可能だが、フレーム取得や音声解析などのAPIアクセスはCORS必須。

6. **`<iframe>` によるクロスオリジンページ埋め込み**  
   - 例:  
     ```html
     <iframe src="https://cross-origin.com"></iframe>
     ```  
   - 表示は可能だが、JavaScriptでDOMへアクセスは不可（同一オリジン制約は働く）。

7. **`<object>` / `<embed>` / `<applet>` によるクロスオリジンリソース読み込み**  
   - 例:  
     ```html
     <object data="https://cross-origin.com/file.pdf" type="application/pdf"></object>
     ```  
   - 埋め込み表示はできるが、中身の直接操作は不可。

8. **`<form>`要素によるフォーム送信**  
   - 例:  
     ```html
     <form action="https://cross-origin.com/mail.php" method="post">
     ```  

---

これらのHTML要素からのアクセスも、`crossorigin` 属性やCORS対応することでアクセス制御できる。<br><br>
CORSとは、ここまでの説明通りクロスオリジンから受信したレスポンスのリソースへのアクセスは禁止されているものの、レスポンスに付与されている一連のHTTPヘッダによって、**サーバーからアクセス許可が出ているリソースへはアクセスできる**ようになる仕組みを指す。
