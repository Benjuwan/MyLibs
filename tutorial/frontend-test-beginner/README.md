## Frontend Test Beginner
書籍『[フロントエンド開発のためのテスト入門 今からでも知っておきたい自動テスト戦略の必須知識](https://www.shoeisha.co.jp/book/detail/9784798178639)』の個人用学習リポジトリ

- [当該書籍公式リポジトリ](https://github.com/frontend-testing-book)
    - 3章から6章まで：[unittest](https://github.com/frontend-testing-book/unittest)
    - 7章から10章（+付録）まで：[nextjs](https://github.com/frontend-testing-book/nextjs)

### 書籍で使用しているライブラリやフレームワーク
- React：UIコンポーネントライブラリ
- Next.js：ReactベースのWebアプリケーションフレームワーク
- Zod：バリデーションライブラリ
- React Hook Form：Reactフォーム実装ライブラリ
- Prisma：データベースに接続するORMライブラリ
- Jest：CLIベースのテスティングフレームワーク、テストランナー
- Playwright：Microsoftが開発したWeb UI自動化テストフレームワーク（E2Eテストツール）。ヘッドレスブラウザを含んだテスティングフレームワーク、テストランナー
- reg-suit：ビジュアルリグレッション / テスティングフレームワーク
- Storybook：UIコンポーネントカタログ。個々のUIコンポーネントを単体で開発、テスト、文書化できるツール

## 大前提として
### `Behavior-Driven Development`：ビヘイビア駆動開発を意識
テストはあくまで**振る舞い・挙動**にスポットをあてる。実装ロジックや技術的観点などユーザー目線（UX基準）から外れたところをテスト軸としない。<br>
何のためのテストなのか「目的」と「手段」を履き違えないよう`BDD`（`Behavior-Driven Development`）ビヘイビア駆動開発を意識したい。

### 条件分岐に注目
複雑なプログラムにバグが混入する代表例として**条件分岐が原因**となっているケースがある。そのため**条件分岐に着目してテストを書いていくのが基本的な活動**となる。

### テストを書く時は**汎用性、再利用性、共通化などDIYを意識しない**こと（過度な共通化をしない）
テスト対象に対して複数または異なるスタブを適用したい場合は**テストごとにファイルを分離**するほうが良い。テストは**そのケースを検証するためのもの**なので、統合したりするとテストケースの管理・把握や検証精度にも影響が出てしまう。テストは読みやすさと独立性を優先する。

### Testing Libraryの哲学
Testing Libraryの哲学は「**ユーザーが要素を見つける方法でテストを書く**」ことなので、クラス名やID名、DOM要素などではなく、見た目やラベルで要素を特定するアクセシビリティを重視した優先順位（＝`...ByRole`系）で書いていくのが理想的なテストコード。<br>
※アクセシビリティを優先したテストコードを書くことで、必然的にアクセシビリティに配慮したコードになっていく複合的な利点もある。

---

## テストの範囲と種類
1. ライブラリが提供する関数
2. ロジックを担う関数
3. UIを表現する関数
4. Web API クライアント
5. APIサーバー
6. DB（サーバー）

### 静的解析
TypeScriptやESLintによる静的解析を指す。一つひとつのモジュール内部検証だけでなく、2と3の間、3と4の間、というように**隣接するモジュール間連携の不整合**に対して検証する
- ESLint：<br>不適切な構文を回避することで潜在的なバグ混入を未然に防止できたり、将来的に非推奨となるAPIに気づきやすくなったりするといった「コード規約の強制（コーディングガイドラインの設定）」を実施

### 単体テスト（ユニットテスト）
2のみ、3のみ、というように**モジュール単体が提供する機能（振る舞い）**にスポットをあてたテスト。独立検証が可能なためアプリケーション稼働時にはめったに発生しないケース（エッジケース / コーナーケース）の検証に向いている。<br>
※昨今はAIを活用すれば単体テストは比較的容易に作成できる

> [!NOTE]
> テスト対象モジュールが定められた入力値から期待する出力値が得られるかをテストする。SPAを一例にすると、入力値（`props`）から出力値（JSX：HTMLのブロック）を得るUIコンポーネントは、関数の単体テストと同じ要領で検証できる。<br>
> 単体テストは**テスト対象モジュール（の振る舞い）にフォーカスする**ため、エッジケースや例外を考慮するのに有用で**挙動や処理の想定ケース考慮漏れの防止にも寄与**する。

### 結合テスト（インテグレーションテスト）
1～4まで、2～3まで、というように**モジュール同士をつなげることで提供できる機能（振る舞い）**にスポットをあてたテスト。範囲が広いほどテスト対象を効率よくカバーできるが、相対的にざっくりとした検証になる傾向がある。

> [!NOTE]
> 多くのWebアプリケーションは様々な機能が関連しあってサービスとして成り立っているので、必然的にボリュームが大きくなる傾向にある。<br>
> 複数モジュールが連携する機能（振る舞い）にフォーカスをあてるテストという性質から、結合テストとしてカバーする領域・範囲を定義し、柔軟に（広い範囲での結合テスト、または狭い範囲での結合テストなど）組み分けられるのも特徴。<br>
> 例えば、エッジケースを考慮した複雑なケースの場合には狭い範囲にしたほうがテスト対象が明確になりやすい。

### E2Eテスト
1～6を通して、ヘッドレスブラウザ + UIオートメーションで実施するテスト。本環境テストに近い性質なので、最も広範囲な結合テストとなり、アプリケーション稼働状況に忠実な検証となる。
- `ヘッドレスブラウザ`：<br>GUI（グラフィカル・ユーザー・インターフェース）を備えていないブラウザを指す。

> [!NOTE]
> UIテストに加え、外部ストレージや連携するサブシステムを含むテストを行える。フォームテストを一例にすると、入力内容に応じて保存された値が更新されるので、画面をまたいだ機能（入力内容確認ページ）はもちろん、外部連携（住所の自動入力）が正常に機能しているかチェックできる。

## テストの目的（テストタイプ）
機能テスト、非機能テスト、ホワイトボックステスト、リグレッションテストなどがあり、フロントエンドで代表的なのは以下となる。

### 機能テスト（操作・インタラクションテスト）
開発対象の機能（振る舞い）に不具合がないかを検証する。フロントエンドでは、主にUIコンポーネントの操作（インタラクション）がアプリケーションの挙動起点となるので、インタラクションテストが機能テストに位置付けられる。ブラウザAPIを用いるのが重要なテストの場合はE2Eテストツールを通じて自動テストを書く（例：[playwrightのcodegen](https://zenn.dev/b13o/articles/about-playwright#playwright-%E3%81%AE-codegen%EF%BC%88%E3%83%86%E3%82%B9%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%EF%BC%89%E3%81%A8%E3%81%AF%EF%BC%9F)）。

### 非機能テスト（アクセシビリティテスト）
心身特性に隔てのないサービスを提供できているかという検証。Webアクセシビリティに関するAPIが様々なプラットフォームで展開されており、自動テストでも客観的に判定できる環境が整っている。
- 事例：
    - チェックボックスとしてチェックできる
    - エラーレスポンスが表示された場合、エラーテキストが読み上げ対象としてレンダリングされる
    - 表示中の画面でアクセシビリティ違反がないかチェックする
        - アクセシビリティ違反例：キーボード入力による操作が充実しているか、視認性に問題ないコントラスト比になっているか

### リグレッションテスト（デグレーションテスト）
デグレーションが発生していないかを確認するためのテスト手法。ある特定時点から前後の差分を検出して**想定外の不具合が発生していないか**を検証するテストを指す。
- デグレーション：<br>システムやプログラムの機能が、修正や更新によって劣化してしまう現象

#### ビジュアルリグレッションテスト
レンダリング状態（見た目）に特化したリグレッションテストを指す。<br>
CSSはUIコンポーネントへのスタイル指定のみならず、ブラウザに読み込まれた全てのスタイルシートから影響を受ける。<br>
ヘッドレスブラウザに描画された状態をキャプチャし、キャプチャ画像を比較検証することで差分チェックする。<br>
インタラクション（操作）によって変化したUIコンポーネントの差分比較も検証可能。
- 事例：
    - UIコンポーネント単体：ボタンの見た目に、リグレッションがない
    - インタラクション：メニューバーを開いた状態に、リグレッションがない
    - レイアウト崩れ：表示画面に、リグレッションがない

---

## テスト戦略モデル
E2Eテストは最も忠実性の高いテストとなるが、テスト対象によってはステージング環境（本環境のミラーDBやミラーサーバー）を用意・設置したりするコスト（時間と労力）が出てくる。<br>
さらに、他の外部システムからのレスポンスをテスト実行の度に全て待つ必要があるケースも出てくる。他にも外部連携システム自体は自分たちでコントロールできないので、検証が不安定になる可能性もある。<br>
つまり、忠実なテストをしようとすればメンテナンス工数や実行時間を含めてコストが増えていく傾向となる。

> [!NOTE]
> このような状況から現状推奨されているテスト戦略モデルは**テスティングトロフィー型**というモデルになっている。

### アイスクリームコーン型
#### 特徴
- 手動テスト > E2Eテスト > 結合テスト > 単体テスト<br>
アイスクリームコーンのように、上層（アイス本体＝手動テスト）から下層（結合・単体テスト＝コーン部分）へとテストボリュームが減っていくモデル

#### 概要
上層のテストが多く書かれたモデルで、アンチパターンとして参照されている。理由は、運用コストの高さと、まれに失敗する不安定なテストにより多くのコストを要するため。上層のテストが多いため、テストの実行時間に何十分もかかってしまう場合があり、そうなると開発フローに影響が出るほか検証頻度も自然と低下してしまう状況になりかねない。

### テストピラミッド型
#### 特徴
- 単体テスト < 結合テスト < E2Eテスト < 手動テスト<br>
ピラミッドのように、下層（結合・単体テスト＝土台部分）から上層（登頂部＝手動テスト）へとテストボリュームが増えていくモデル

#### 概要
下層のテストを充実させることで、より安定した費用対効果の高いテスト戦略になる、という考えに基づいたモデル。上層のテストはコストが高いので、下層のテストにボリュームを取ることで安定かつ高速なテストを可能とする優れたテスト戦略である。

### テスティングトロフィー型
#### 特徴
トロフィーのように土台（静的解析）があって、上部に本体（単体・結合・E2Eテスト）があるモデルで、結合テストに最も多くのボリュームを割いているのが大きな特徴。

- E2Eテスト：10～20%
- 結合テスト：45～50%
- 単体テスト：35～40%
- 静的解析：基盤（必須前提）

#### 概要
前述のとおり、テスティングトロフィー型では**結合テストが最も重視**されている。フロントエンド開発において**UI単体で成立する機能はほとんどなく、多くが複数モジュールの連携によって構成されている特徴**に注目したモデルとなる。<br>
フロントエンドでは、主にUIコンポーネントの操作（インタラクション）がアプリケーションの挙動起点となるので、 **ユーザー操作を起点とした結合テストを充実させることがより良いテスト戦略になる**という意図が込められている。

---

## テストの実行
※以下の説明は、Jestをインストール済みで、`package.json`の`scripts`セクションにテストコマンドの追記も完了している状態を前提としている。[詳細情報が必要な場合はこちら](./use-typescript-config-jest.md)。

### `npm test`
- 全体テスト：<br>
プロジェクトに存在する`.test`ファイルを全て検証するので時間がかかる

### `npm test ファイルパス`
- 単体テスト：
    - ファイルパス指定は`/`でないと機能しない<br>
    ※WindowsOSでのファイルパスコピー時は`\`（バックスラッシュ）となるので要注意
    - （※`Windows OS`の場合のみ）ファイル名にクオーテーションは不要<br>
    ※書籍では`npm test 'ファイルパス'`で紹介されているが、それだと`Windows OS`では実行できないので注意

```bash
# ※`Windows OS`の場合、ファイルパスにクオーテーションは不要
npm test src/example.test.ts
```

### VSCode拡張機能`Jest Runner`を利用
テストファイルのコード上で`Run|Debug`を実行できる

---

## 用語集
### Webアクセシビリティ
ユーザーの心身特性に隔てなくWebが利用できる水準のこと

### アサート
検証値が期待値通りであるという検証を行うこと

### ステージング環境
より本番環境に近い構成をテスト用に用意した環境のこと

### フィクスチャー
（Web API から取得するデータなど）レスポンスを再現するためのテスト用データ（アタリ）のこと

### モック生成関数
テストで必要なセットアップを必要最小限のパラメーターで切り替え可能にしたユーティリティ関数（＝任意の自作関数）

### 偽陽性(false positive)
実際には、機能に問題がないのにテストが失敗すること
